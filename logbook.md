# Les 1 - de basis + experimenten reconnaissance

_Jelle Firlefyn - 3ITCSC1_

- Wat is ethical / white-hat hacking?

  - **Antwoord:** Het is het testen van systemen op kwetsbaarheden om ze te herstellen, niet om ze te misbruiken.

- In welke context gebeurt dit?

  - **Antwoord:** Bedrijven huren "goede" hackers in om hun systemen proactief te testen.

- Wat zijn de basis-voorwaarden om aan ethical hacking te doen?

  - **Antwoord:**
    - Toestemming van de eigenaar.
    - Duidelijke opdrachtscope.
    - Ethiek en rapportage van bevindingen.

- Wat is pentesting?

  - **Antwoord:** Een cyberaanval uitvoeren om kwetsbaarheden te vinden.

- Wat zijn de verschillende fasen die in de literatuur worden beschreven?

  - **Antwoord:** Fasen zijn:
    - Planning en verkenningsfase.
    - Scannen.
    - Toegang krijgen.
    - Toegang behouden.
    - Analyse.
  - Meer bepaald: wat wordt begrepen onder “reconaissance”. Beschrijf!
    - **Antwoord:** Informatie verzamelen over het doelsysteem.

- Wat is bug bounty?

  - **Antwoord:** Een programma waarbij je beloond wordt voor het melden van beveiligingskwetsbaarheden.

  - Welke zijn de mogelijkheden om aan bug bounty te doen?
    - **Antwoord:** Platforms zoals HackerOne, Bugcrowd, Intigriti joinen en op de hoogte blijven via communitykanalen.

- Hoe verhoudt het Belgische Intigriti (intigriti.com) platform zich hiertoe?

  - **Antwoord:** Intigriti verbindt ethische hackers met bedrijven voor het vinden van kwetsbaarheden. Intigriti is zeker niet minder waard als andere bedrijven.

- Ethical Hacking - Python - 23243
  - Hoe ga je te werk bij bug bounty?
    - **Antwoord:**
      1. Begrijp de regels.
      2. Kies een doel.
      3. Test en rapporteer.
  - Wat is de beste aanpak voor een beginnend bounty hunter?
    - **Antwoord:**
      1. Leren en oefenen.
      2. Start met kleinere programma's.
      3. Betrokkenheid bij de community.

Om verder meer informatie op te doen over wat bug bounty juist is en wat hierbij gezocht wordt heb ik een account aangemaakt op Intigriti. Wat me hieruit vooral uit opvalt is het feit dat de requests gelimiteerd moeten worden tot een bepaald aantal seconden. Verder lijkt het doel enkel te zijn om toegang te krijgen tot data of interfaces die normaal niet toegankelijk zijn voor het publiek.

Hierna ben ik verder gaan kijken wat de scope van mijn programma zal worden. Voorlopig ben ik de volgende scope bekomen:

- Port scanner
- Vulnerability scanner
- Web application scanner
- Network sniffer
- Brute force tool

Aangezien de meeste van deze tools relatief nieuw zijn ben ik ChatGPT gaan vragen om dit plan verder uit te diepen.

```text
ChatGPT response


1. Reconnaissance Tools:

    Domain and IP Gathering:
        Using libraries like dnspython for DNS queries and lookups.
        Extract subdomains, historical domain data, etc.

    OSINT (Open Source Intelligence):
        Gathering information from publicly available resources.
        Utilize APIs from platforms like Shodan, Censys, etc.

    Network Scanning:
        ARP scan to discover devices in a local network.
        ICMP ping sweep.

2. Vulnerability Assessment:

    Port Scanning:
        Detect open ports on a target.
        Enhancements: Service version detection, banner grabbing.

    Web Vulnerability Scanning:
        Detect common web vulnerabilities like SQLi, XSS, CSRF, etc.
        Use libraries like BeautifulSoup, requests, or even selenium for web interaction and scraping.

    Network Vulnerability Scanning:
        Detect network vulnerabilities or misconfigurations.
        Use tools and libraries like Nmap (via python-nmap).

3. Exploitation Tools:

    Payload Generators:
        Create custom payloads for exploitation.
        Eg: Reverse shells, file downloaders.

    Automation Scripts:
        Automate common exploitation patterns.
        Examples: Trying common passwords, automated SQLi attempts.

4. Post Exploitation:

    Data Extraction:
        Scripts to extract valuable information from compromised systems.
        Eg: Password hashes, sensitive files.

    Lateral Movement:
        Tools to move laterally within a compromised network.
        Eg: ARP poisoning, session hijacking.

    Persistence:
        Tools to maintain access.
        Eg: Backdoors, keyloggers.

5. Web Application Tools:

    Crawlers:
        Navigate through web apps to identify input points and links.
        Use libraries like scrapy.

    Fuzzers:
        Submit multiple inputs to find potential vulnerabilities.
        Use tools like wfuzz or integrate wordlists with custom scripts.

6. Utility Tools:

    Hash Crackers:
        Implement common hashing algorithms and attempt to crack hashes using dictionaries or brute force.

    Encryption/Decryption Tools:
        Implement scripts for common encryption algorithms.

    Steganography Tools:
        Hide or reveal data inside images or other files.

7. Reporting:

    Automated Report Generation:
        After scanning or assessment, generate a comprehensive report.
        Use libraries like rich or fpdf for PDF generation.

    Logging:
        Keep track of all toolkit activities in detailed logs.

8. Integration with Existing Tools:

    APIs & Wrappers:
        Many existing tools like Nmap, Metasploit, or Shodan have Python APIs or wrappers.      Incorporate them to extend your toolkit's capabilities.

9. User Interface:

    CLI (Command Line Interface):
        A well-structured CLI for easy use of the toolkit.
        Use libraries like argparse or click for this.

    GUI (Graphical User Interface):
        Implement a GUI version of your toolkit.
        Use frameworks like tkinter or PyQt
```

Deze ChatGPT prompt heeft zeker geholpen met de scope te leggenn van het programma. Ik wil elk van deze genummerde punten implementeren in mijn programma. Uit de voorbeelden dat ChatGPT gaf kan ik kiezen op welke manier ik het punt uitwerk al dan niet op meerdere manieren. Omdat ik hier nog geen ervaring met heb is het zeker handig om meerdere opties te hebben, zodat ik zo weinig mogelijk tijd verlies en altijd een mogelijke oplossing heb.

```python
import sys
import requests
import socket
import json

if len(sys.argv) < 2:
    print("Gebruik: " + sys.argv[0] + " <url>")
    sys.exit(1)

request = requests.get("https://" + sys.argv[1])
print("\n" + str(request.headers))

geef_host = socket.gethostbyname(sys.argv[1])
print("\nHet ip-adres van " + sys.argv[1] + " is: " + geef_host + "\n")

# ipinfo.io

request_twee = requests.get("https://ipinfo.io/" + geef_host + "/json")
response = json.loads(request_twee.text)

print("Locatie: " + response["loc"])
print("Regie: " + response["region"])
print("Stad: " + response["city"])
print("Land: " + response["country"])
```

Dit script kan helpen met reconnaissance. Hiermee kunnen we de header informmatie vinden, ip address resolutie en locatie van de servers. Hierin staan ook soms rate limits.

Verder kan ik gebruik maken van het nmap script en indien je access krijgt tot het systeem gebruik maken van het script dat screenshots upload naar de FTP server.

# Les 3 - werken met Socket en Scapy

**1. Scope Definitie:**

**1.1 Target market:**

- **Grote Ondernemingen** : Dit zijn meestal de grootste klanten, vaak met meer complexe infrastructuren. Ze vereisen robuuste scanning-mogelijkheden, gedetailleerde rapportage en vaak ook toegewijde ondersteuning.
- **Kleine en Middelgrote Bedrijven (KMB's)**: KMB's hebben betaalbare, eenvoudig te gebruiken oplossingen nodig. Ze beschikken mogelijk niet over een toegewijd IT-beveiligingsteam, dus eenvoud en begeleiding bij het verhelpen zijn essentieel.
- **Individuele Website-eigenaren** : Deze gebruikers hebben vaak basisbehoeften, vooral gericht op webserver kwetsbaarheden. Ze waarderen eenvoud, betaalbaarheid en begeleiding over het verhelpen van kwetsbaarheden.

**1.2 Platform Compatibiliteit:**

- **Windows Server** : Populair in bedrijfsomgevingen. Focus op kwetsbaarheden specifiek voor Windows Server besturingssystemen en bijbehorende services (zoals IIS).
- **Linux Distributies** : Bestrijkt een breed scala, van webservers (bijv. Apache, Nginx) tot databases (bijv. MySQL, PostgreSQL) en meer. Aangezien Linux veel voorkomt in de serverwereld, is het een verstandige keuze om hierop te focussen.

**1.3 Type Kwetsbaarheden:**

#### 1. Web Server Kwetsbaarheden

Voor zowel Windows (IIS) als Linux (Apache, Nginx, enz.):

- **Misconfiguraties** : Standaardinstellingen zijn vaak onveilig. Het controleren van deze misconfiguraties kan potentiële aanvallen voorkomen.
- **Informatielekkage** : Servers die te veel informatie vrijgeven in foutmeldingen of headers, wat kan worden gebruikt voor meer gerichte aanvallen.
- **Directory Traversal en Listing** : Ongeautoriseerde toegang tot mappen, mogelijk gevoelige bestanden onthullend.
- **Blootgestelde Admin Interfaces** : Beheerpagina's of interfaces die openbaar toegankelijk zijn en zonder de juiste authenticatie kunnen worden benaderd.

#### 2. Besturingssysteem Kwetsbaarheden

- **Ongepatchte Software** : Een van de meest voorkomende kwetsbaarheden. Zorgen dat alle software up-to-date is en gepatcht tegen bekende kwetsbaarheden.
- **Open Ports** : Open poorten kunnen poorten zijn voor aanvallen. Het scannen op onnodig open poorten en zorgen dat ze veilig geconfigureerd zijn, is essentieel.
- **Standaard Inloggegevens of Zwakke Wachtwoordbeleid** : Aanvallers gebruiken vaak brute-force technieken om wachtwoorden te raden, vooral als ze standaard of zwak zijn.
- **Onveilige Service Configuraties** : Services die met meer privileges draaien dan nodig of die verkeerd zijn geconfigureerd, kunnen potentiële toegangspunten zijn.

#### 3. Database Kwetsbaarheden

- **SQL Injection** : Een methode waarbij aanvallers kwaadaardige SQL-code kunnen uitvoeren door invoervelden te manipuleren.
- **Onveilige Database Configuraties** : Databases geconfigureerd om verbindingen toe te staan vanuit elke IP, of met zwakke authenticatiemechanismen.
- **Onversleutelde Gevoelige Data** : Databases die gevoelige informatie in platte tekst opslaan of zonder de juiste encryptiemethoden.

#### 4. Algemene Software/Applicatie Kwetsbaarheden

- **Cross-Site Scripting (XSS)**: Aanvallers injecteren kwaadaardige scripts in webpagina's, die vervolgens worden uitgevoerd door een andere eindgebruiker.
- **Cross-Site Request Forgery (CSRF)**: Aanvallers misleiden slachtoffers om acties uit te voeren zonder hun medeweten op een webtoepassing waarop ze zijn geauthenticeerd.
- **Remote Code Execution** : Aanvallers voeren willekeurige code uit op een server op afstand.
- **Local File Inclusion (LFI) & Remote File Inclusion (RFI)**: Aanvallers kunnen bestanden opnemen op een server waartoe ze geen toegang zouden moeten hebben.

#### 5. Middleware/Services Kwetsbaarheden

- **FTP Kwetsbaarheden** : Zoals anonieme FTP-toegang, clear-text authenticatie, of bestand overschrijf kwetsbaarheden.
- **E-mail Server Kwetsbaarheden** : Misconfiguraties kunnen e-mailservers veranderen in open relays, wat leidt tot gebruik ervan voor spam.

#### 6. Netwerk Kwetsbaarheden

- **Man-in-the-Middle (MitM) Attacks**: Aanvallers geven heimelijk informatie door en veranderen mogelijk de communicatie tussen twee partijen die geloven dat ze rechtstreeks met elkaar communiceren.
- **Denial of Service (DoS) of Distributed DoS**: Je moet hier echter voorzichtig mee zijn bij het scannen, omdat je niet per ongeluk een server van een klant wilt uitschakelen.

#### 7. Authenticatie en Sessiebeheer

- **Brute Force Attacks** : Herhaaldelijk combinaties proberen om wachtwoorden te raden.
- **Session Hijacking** : Ongeautoriseerde toegang tot de websessie van iemand anders.
- **Onveilige JWT (JSON Web Tokens) Implementatie**: Als dit niet veilig wordt geïmplementeerd, kan het een vector voor aanvallen zijn.

#### 8. Cloud-specifieke Kwetsbaarheden (voor het geval je hier in de toekomst naartoe gaat)

- **Misgeconfigureerde Cloud Opslag** : Openbaar toegankelijke databuckets of containers.
- **Onveilige Cloud API Sleutels** : Ingebed in code of opgeslagen zonder encryptie.

**1.4 Integratie Mogelijkheden:**

- Momenteel geen, maar overweeg dit voor toekomstige schaalvergroting, aangezien integratie met andere tools/platforms een waardepropositie kan zijn.

**1.5 Diepte van Scannen:**

- **Passief Scannen** : Zorg ervoor dat het niet-intrusief is. Dit kan scannen op versie-informatie, headers en andere naar buiten gerichte details zonder payloads te verzenden of wijzigingen aan te brengen.
- **Actief Scannen** : Aggressiever en kan de serverprestaties beïnvloeden. Dit type kan kwetsbaarheden identificeren door payloads te verzenden, te testen op open poorten en meer. Gebruikers moeten duidelijk worden gewaarschuwd voor mogelijke verstoringen.

**1.6 Overige Functies:**

- **Gebruiksvriendelijk Dashboard** : Duidelijke visuals, eenvoudige navigatie en bruikbare inzichten. Overweeg om het volgende op te nemen:
  - Kwetsbaarheidstrends in de loop van de tijd
  - Indeling naar ernst
  - Makkelijk te begrijpen oplossingstips

**1.7 Regelgeving en Compliance:**

- Later te bepalen. Onthoud echter dat bedrijven helpen om compliant te blijven een belangrijk verkoopargument kan zijn.

**1.8 Service Model:**

- **Cloud-Based** : Vereenvoudigt toegang en updates.
- **Abonnementsmodel met Tiers** :
  - **Basis Tier** : Voor individuele website-eigenaren, beperkte scans.
  - **KMB Tier** : Voor kleine en middelgrote bedrijven, gematigd aantal scans.
  - **Onderneming Tier** : Voor grote ondernemingen, uitgebreide scans, mogelijk toegewijde ondersteuning.

Hieruit heb ik volgende structuur opgebouwd om dit programma OOP wijs te kunnen ontwikkelen.

```text

vuln_scanner/
│
├── core/                      # Core scanning modules and utilities
│   ├── web_server_scans/
│   │   ├── __init__.py
│   │   ├── misconfigurations.py
│   │   ├── information_leakage.py
│   │   ├── directory_traversal.py
│   │   └── admin_interfaces.py
│   │
│   ├── os_scans/              # OS level scans (future)
│   ├── db_scans/              # Database scans (future)
│   └── utils/                 # Shared utilities
│       ├── __init__.py
│       ├── http_utils.py      # Functions for making HTTP requests, parsing responses, etc.
│       └── network_utils.py   # Functions for network level tasks (e.g. port scanning)
│
├── tests/                     # Unit tests and integration tests
│   ├── web_server_scans/
│   ├── os_scans/
│   └── db_scans/
│
├── reports/                   # Templates and utilities for generating reports
│
├── config/                    # Configuration files (e.g. list of common directories, ports, etc.)
│   ├── directories.json
│   ├── ports.json
│   └── settings.py            # General settings (e.g. timeouts, user-agents)
│
├── logs/                      # Log files and log configurations
│
├── main.py                    # Entry point of the application
└── README.md

```

# Les 5 - Python web hacking / Scapy / Cryptografie

Update aan scope:

```text

vuln_scanner/
│
├── core/                      # Core scanning modules and utilities
│   ├── web_server_scans/
│   │   ├── __init__.py
│   │   ├── misconfigurations.py
│   │   ├── information_leakage.py
│   │   ├── directory_traversal.py
│   │   └── admin_interfaces.py
│   │
|   ├── network_scans/
│   │   ├── __init__.py
│   |   ├── host_discovery.py
│   |   ├── service_discovery.py
│   |   ├── remote_os_detection.py
│   |   ├── pcap_analysis.py
│   |   ├── ping_sweep.py
│   |   └── network_map.py
│   │
│   ├── os_scans/              # OS level scans (future)
│   ├── db_scans/              # Database scans (future)
│   └── utils/                 # Shared utilities
│       ├── __init__.py
│       ├── http_utils.py      # Functions for making HTTP requests, parsing responses, etc.
│       └── network_utils.py   # Functions for network level tasks (e.g. port scanning)
│
├── tests/                     # Unit tests and integration tests
│   ├── web_server_scans/
│   ├── network_scans/
│   └── db_scans/
│
├── reports/                   # Templates and utilities for generating reports
│
├── config/                    # Configuration files (e.g. list of common directories, ports, etc.)
│   ├── directories.json
│   ├── ports.json
│   └── settings.py            # General settings (e.g. timeouts, user-agents)
│
├── logs/                      # Log files and log configurations
│
├── main.py                    # Entry point of the application
└── README.md

```

Verder heb ik een GitHub repository aangemaakt om hierop mijn code te plaatsen om duidelijke commits te maken en om verlies van mijn code te preventeren.

[Github Repository](https://github.com/JelleFirlefyn/pentest-toolkit)

Tijdens week 3 van het project heb ik Scapy gebruikt. Om netwerk scans te ontwikkelen. Het script geeft nu een output als deze: `IP: 192.168.0.1 MAC: 78:da:c4:g6:b4:70 Linux (Kernel 3.x) Open ports: [22, 53, 80, 443]`.

Ik begon met basisoperaties zoals het ontdekken van hosts binnen een bepaalde IP-bereik en het uitvoeren van poortscans. Naarmate ik me meer verdiepte in de mogelijkheden van Scapy, ontwikkelde ik ook geavanceerdere functies zoals het detecteren van het besturingssysteem van een host door actieve vingerafdruktechnieken en het analyseren van PCAP-bestanden om specifiek netwerkverkeer, zoals HTTP, SMTP, POP3 en IMAP, te identificeren.

Na het ontwikkelen van deze afzonderlijke functies, besloot ik ze te integreren in één samenhangend CLI (Command Line Interface) programma. Om dit te bereiken, maakte ik gebruik van sys.argv in Python. Dit stelde me in staat om commandoregelargumenten te accepteren, waardoor gebruikers specifieke taken konden specificeren en de nodige parameters konden doorgeven, zoals IP-adressen en subnetmaskers.

Het eindresultaat was een veelzijdig hulpmiddel dat een reeks netwerktaken kon uitvoeren vanaf de commandoregel. Het proces van het leren en toepassen van Scapy, gecombineerd met het ontwikkelen van een CLI-interface, was zowel uitdagend als lonend. Het gaf me waardevolle inzichten in netwerkanalyse en -beveiliging, en ik kijk ernaar uit om deze kennis in de toekomst verder toe te passen.

# Les 7 - Projectwerk

Deze keer heb ik ondervonden dat mijn vorige scope(s) eigenlijk niet zeer hulpvol waren. De lessen geven telkens een onderwerp om te onderzoeken. Wanneer dit onderwerp niet samenloopt met mijn scope is dit nutteloos. Hierdoor ben ik in week 4 zonder naar de scope te kijken begonnen met scripts te schrijven voor web server scans.

Aan de start heb ik de scripts die waren voorgeschreven in de les 4 PDF getest maar deze lijken niet werken. Eerst starte ik met het wordpress brute force script. Jammer genoeg heb ik dit hele script herschreven zodat het gebruikt maakt van beautifulsoup. Dit heeft nam veel meer tijd in beslag als ik had verwacht. Hierna viel me ook op dat het brute force directories script ook niet werkte. Dit ben ik dus ook vanaf nul aan begonnen.

Om mijn huidige scripts die ik geschreven heb te doen werken, of toch beter heb ik de mogelijkheid toegevoegd om proxies te gebruiken. Volgende week zou ik graag starten met het developen van de interface waarbij script gebruikt kunnen worden en proxy files of wordlists kunnen toegevoegd worden. De reden waarom ik hier nu al met wil starten is omdat ik nog nooit gebruik heb gemaakt van Flask of Django en ik wil eens testen op welke manier ik de script kan integreren. Indien nodig kan ik dan rekening houden met bepaalde problemen bij het schrijven van tests in de toekomst.

De huidige structuur van het project:

```text

vuln_scanner/
│
├── core/                      # Core scanning modules and utilities
│   ├── web_server_scans/
│   │   ├── __init__.py
│   │   ├── misconfigurations.py
│   │   ├── directory_traversal.py
│   │   ├── wordpress_brute_force.py
│   │   └── admin_interfaces.py
│   │
|   ├── network_scans/
│   │   ├── __init__.py
│   |   ├── host_discovery.py
│   |   ├── service_discovery.py
│   |   ├── remote_os_detection.py
│   |   ├── pcap_analysis.py
│   │
│   └── utils/                 # Shared utilities
│       ├── __init__.py
│       ├── check_proxies.py      # Proxy validation
│       └── get.py   # Read specific files
│       └── utilities.py   # Re-usable functions inside utils module
│
│
├── config/                    # Configuration files (e.g. list of common directories, ports, etc.)
│   ├── valid_proxies.txt
│   ├── user_agents.txt
│   └── proxies.txt
│
│
├── main.py                    # Entry point of the application
└── README.md

```
