from django.shortcuts import render
from django.http import HttpResponse
from .forms import URLInputForm
from .web_server_package import server_software_eol, admin_interface
from .tasks import run_directory_traversal, brute_force_login_task
from celery.result import AsyncResult
from django.http import JsonResponse
from utils.get import readfile

# Create your views here.

def index(request):
    return render(request, 'web_server_scans/index.html', {'current_page': 'web_server_scans'})

def fetch_task_results(request, task_id):
    task_result = AsyncResult(task_id)

    if task_result.ready():
        # Task has finished, return the result.
        return JsonResponse({
            'complete': True,
            'results': task_result.result  # Ensure this is JSON serializable
        })
    else:
        # Task is still running or pending.
        return JsonResponse({'complete': False, 'results': "Directory traversal is executing. Do not leave or refresh this page."})

def web_server_scans_view(request):
    server_software_result = None
    admin_pages_result = None
    task_id = None

    if request.method == 'POST':
        form = URLInputForm(request.POST)
        if form.is_valid():
            url = form.cleaned_data['url']
            username = form.cleaned_data['username']
            wordlist = form.cleaned_data['wordlist'] or 'test.txt'
            file_extensions = form.cleaned_data['file_extensions'] or '.php'
            threads = form.cleaned_data['threads'] or 200

            # Determine which button was clicked
            if 'check_server_software' in request.POST:
                checker = server_software_eol.ServerSoftwareCheck()
                server_software_result = checker.check(url)
            elif 'directory_traversal' in request.POST:
                # Trigger the Celery task for directory traversal
                task = run_directory_traversal.delay(url, wordlist, file_extensions, threads)
                task_id = task.id
            elif 'detect_admin_pages' in request.POST:
                exposed_admin_paths = admin_interface.detect_admin_pages(url)
                admin_pages_result = {'exposed_admin_paths': exposed_admin_paths}
            elif 'wordpress_bruteforce' in request.POST:
                passwords = readfile(wordlist)
                for password in passwords:
                    brute_force_login_task.delay(url, username, password)

    else:
        form = URLInputForm()

    context = {
        'form': form,
        'server_software_result': server_software_result,
        'admin_pages_result': admin_pages_result,
        'task_id': task_id,
    }

    return render(request, 'web_server_scans/index.html', context)
